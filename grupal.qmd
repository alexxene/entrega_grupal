---
title: "Entrega grupal"
author: "Iratxe Valero Ochoa (DNI:02724987Q), 
        Ángela García Muñoz (DNI:01840008P),
        Javier Ruiz (DNI:25449733A), 
        Javier Muñoz Zacarés (DNI:55136745H),
        Xin Yue Huang (NIE:Y8908945R),
        Alexandra Mihaela Ene (NIE: Y3510242L),
        María Belén Lavanda Rocano (DNI:02723226A) "
format:
  revealjs:
    slide-number: true
    theme: [style.scss]
    embed-resources: true
execute: 
  echo: true
---

## Paquetes necesarios {background-image="fondo_diapos.png" background-size="cover"}

```{r}
rm(list = ls())
library(tidyverse)
library(dplyr)
library(glue)
library(forcats)
library(lubridate)
library(extrafont)
library(ggplot2)
library(patchwork)
library(plotly)
library(mapSpain)
```

------------------------------------------------------------------------

## Datos {background-image="fondo_diapos.png" background-size="cover"}

::: incremental
-   `election_data`: archivo con las elecciones al congreso
-   `cod_mun`: archivo con los códigos y nombres de cada municipio
-   `abbrev`: siglas de cada partido
-   `surveys`: encuestas electorales desde 1982.
:::

. . .

```{r}
#| results: 'hide'

election_data <- read_csv(file = "./data/datos_elecciones_brutos.csv")
cod_mun <- read_csv(file = "./data/cod_mun.csv")
surveys <- read_csv(file = "./data/historical_surveys.csv")
abbrev <- read_csv(file = "./data/siglas.csv")
```

------------------------------------------------------------------------

## Limpieza de datos {background-image="fondo_diapos.png" background-size="cover"}

Nos ocupamos primero de las encuestas:

Eliminar los datos de `surveys`:

::: incremental
-   *se refieran a elecciones* <mark>anteriores</mark> a 2008

-   *sean a pie de urna*

-   *tamaño muestral* <mark>desconocido</mark> o <mark>inferior a 500</mark>.

-   *tenga 1 día o menos de trabajo de campo.*
:::

. . .

```{r}
surveys <- 
  surveys|> 
  select(-type_survey) |>
  filter(exit_poll == FALSE) |> 
  filter((field_date_to-field_date_from) > 1) |> 
  filter(size>=500 & !is.na(size)) |> 
  filter(date_elec>'2008-1-1')

```

------------------------------------------------------------------------

##  {background-image="fondo_diapos.png" background-size="cover"}

Seguimos con los datos electorales

```{r}

election_data <-
  election_data |>
  select(-c(tipo_eleccion,codigo_distrito_electoral,
            numero_mesas, vuelta))

#Combinamos los codigos para formar id_municipio
election_data <- 
  election_data|> 
  mutate(id_municipio = 
           glue("{codigo_ccaa}{codigo_provincia}{codigo_municipio}")) |> 
  relocate(id_municipio, .before=codigo_ccaa)

election_data <- 
  election_data |> 
  select(-c(codigo_ccaa,codigo_provincia,
            codigo_municipio,participacion_1,participacion_2))

```

------------------------------------------------------------------------

##  {background-image="fondo_diapos.png" background-size="cover"}

```{r}
#Configuramos la fecha predeterminada como el día 1 y unimos mes con año 
election_data <- 
  election_data|> 
  mutate(fecha = glue("1-{mes}-{anno}")) |> 
  relocate(fecha, .before=anno) |> 
  mutate(fecha=dmy(fecha)) |> 
  select(-c(anno,mes))
```

Convertimos `election_data` en tidydata

```{r}
election_data <- 
  election_data |> 
  pivot_longer(
    cols = "BERDEAK-LOS VERDES":"COALICIÓN POR MELILLA", 
    names_to = "partidos", 
    values_to = "votos", 
    values_drop_na = TRUE )
```

------------------------------------------------------------------------

##  {background-image="fondo_diapos.png" background-size="cover"}

Utilizamos la variable **partidos** para agrupar todos ellos en solo **12**:

-   *"PP" , "UP", "PSOE" , "PNV" , "Cs" , "ERC" , "CIU"*

-   *"MP" , "VOX", "BNG", "EH-BILDU" ,"OTROS"*

#### Manera 1

```{r}
resumen <- 
  election_data |> 
  mutate('siglas' = case_when(
  str_detect(partidos, regex("EZKER BA|ENTESA|PODEM|COMPROMÍS|IZQUIERDA UNIDA|ESQUERRA UNI|ESQUERDA UNI|I\\.U\\.|IU ")) ~ "UP",
  str_detect(partidos, "PP|PARTIDO POPULAR|PARTIT POPULAR") ~ "PP",
  str_detect(partidos, "PNV|PARTIDO NACIONALISTA VASCO") ~ "PNV",
  str_detect(partidos, "PSOE|PSC|PARTIDO SOCIALISTA|PARTIT SOCIALISTA|PARTIT DELS SOCIALISTES |PARTIDO DOS SOCIALISTA") ~ "PSOE",
  str_detect(partidos, "MÁS PAÍS|PAÍS|MÉS COMPROM") ~ "MP",
  str_detect(partidos, "VOX") ~ "VOX",
  str_detect(partidos, "AMAIUR|ARALAR|EUSKO|EUSKAL HERRI|BILDU") ~ "EH-BILDU",
  str_detect(partidos, "ERC|ESQUERRA REPUBLICANA DE C|ESQUERRA REPUBLICANA$|ESQUERRA REPUBLICANA/") ~ "ERC",
  str_detect(partidos, "BNG|BLOQUE") ~ "BNG",
  str_detect(partidos, "CIUTADANS|PARTIDO DE LA CIU") ~ "Cs",
  str_detect(partidos, "CONVERGENCIA I| CONVERGENCIA i|CONVERGÈNCIA|UNIÓ D") ~ "CIU", 
  TRUE ~ "OTROS"
)) 
unique(resumen$siglas)
```

------------------------------------------------------------------------

##  {background-image="fondo_diapos.png" background-size="cover"}

#### Manera 2

```{r}
#Primero tenemos que filtrar el dataset abbrev ya que hay partidos que aceptan múltiples siglas 
abbrev_sinrepes <- 
  abbrev |> 
  group_by(denominacion) |> 
  slice(1)

# Ahora juntamos el dataset election_data con abbrev_sinrepes para darle a cada partido su correspondiente abreviatura
resumen_2 <- 
    election_data |> 
    left_join(abbrev_sinrepes,
              by = c('partidos' = 'denominacion'))
  
resumen_2 <- 
  resumen_2 |> 
   mutate(siglas = case_when(
     str_detect(siglas, regex("ARALAR|^EA$|AMAIUR|EH Bildu", ignore_case = TRUE)) ~ 'EH-BILDU',
     str_detect(siglas, regex("EB-B|ENTESA|PODEMOS|EZKERRA|UP-UPeC|I\\.U\\.", ignore_case = TRUE)) ~ 'UP',
     str_detect(siglas, regex("^PP$|P\\.P-E\\.U\\.|PP-PAR|PP-FORO|PP-UPM", ignore_case = TRUE)) ~ 'PP',
     str_detect(siglas, regex("PNV", ignore_case = TRUE)) ~ 'PNV',
     str_detect(siglas, regex("PSOE|PSC|PSPC|PSE", ignore_case = TRUE)) ~ 'PSOE',
     str_detect(siglas, regex("PAÍS|MÉS COMPROM", ignore_case = TRUE)) ~ 'MP',
     str_detect(siglas, regex("VOX", ignore_case = TRUE)) ~ 'VOX',
     str_detect(siglas, regex("C's", ignore_case = TRUE)) ~ 'Cs',
     str_detect(siglas, regex("CiU|CDC|unio.cat", ignore_case = TRUE)) ~ 'CIU',
     str_detect(siglas, regex("ERC", ignore_case = TRUE)) ~ 'ERC',
     str_detect(siglas, regex("BNG|NÓS", ignore_case = TRUE)) ~ 'BNG',
    # Partidos que no aparecen en abbrev que tenemos que incluir'
     str_detect(partidos, regex("PARTIT POPULAR|PARTIDO POPULAR|\\(PP\\)", ignore_case = TRUE)) ~ 'PP',
     str_detect(partidos, regex("CIUTADANS|PARTIDO DE LA CIU", ignore_case = TRUE)) ~ 'Cs',
     str_detect(partidos, regex("CONVERGÈNCIA I", ignore_case = TRUE)) ~ 'CIU',
     str_detect(partidos, regex("IZQUIERDA UNIDA|EZKER ANITZA|ESQUERRA UNIDA|^IU$|PODEMOS|AHAL DUGU|ESQUERDA UNIDA-OS VERDES", ignore_case = TRUE)) ~ 'UP',
     str_detect(partidos, regex("PSOE|SOCIALISTA OBRER ESPANYOL|DOS SOCIALISTAS", ignore_case = TRUE)) ~ 'PSOE',
     str_detect(partidos, regex("(EH Bildu)|PARTIDO POLITICO ARALAR|EUSKO", ignore_case = TRUE)) ~ 'EH-BILDU',
     str_detect(partidos, regex("ESQUERRA REPUBLICANA/CATALUNYA SÍ|ESQUERRA REPUBLICANA$", ignore_case = TRUE)) ~ 'ERC',   
     TRUE ~ 'OTROS'))

unique(resumen_2$siglas)
```

------------------------------------------------------------------------

##  {background-image="fondo_diapos.png" background-size="cover"}

Comprobamos si los resultados obtenidos de las 2 maneras son similares:

```{r}
resumen_agg <- 
  resumen |> 
  group_by(siglas,fecha) |> 
  summarise(total_votos_resumen = sum(votos, na.rm = TRUE),.groups = "drop")

resumen_2_agg <- 
  resumen_2 |> 
  group_by(siglas,fecha) |> 
  summarise(total_votos_resumen_2 = sum(votos, na.rm = TRUE),.groups = "drop")

#filtramos por aquellos donde hay diferencias
resumen_total<-
  resumen_agg |> 
  inner_join(resumen_2_agg,by=c("siglas","fecha")) |> 
  mutate(dif=total_votos_resumen-total_votos_resumen_2) |> 
  filter(dif!=0) |> 
  arrange(desc(dif))

resumen_total
```

------------------------------------------------------------------------

##  {background-image="fondo_diapos.png" background-size="cover"}

Hemos descubierto que las diferencias principales están en en CIU y UP en 2015. `Resumen` le da 630.000 votos a CIU, pero `resumen2` solo 65.000, según la web del ministerio del interior obtuvieron 567.000 (ver fichero Elecciones.xls en el repositorio de Github).

En cuanto a los votos en 2015 para UP, si se suman los de Podemos, Coalición "En Comú Podem” (En Comú), Coalición “Unidad Popular” y Coalición “Compromís - Podemos - És el Moment”, el ministerio de interior dice que obtuvieron 5.700.000 votos, muy cercano al cálculo de `resumen`, mientras que `resumen2` se queda 500.00 votos corto.

Y parecido ocurre con la agrupación para 2016 para UP: `resumen` 4.700.000 vs `resumen2` 4.200.000 vs ministerio 5.000.000.

Por tanto creemos que la agrupación `resumen` es más precisa y usaremos esa agrupación para el resto del trabajo.

------------------------------------------------------------------------

## Pregunta_0 {background-image="fondo_diapos.png" background-size="cover"}

Mostrar un gráfico con los resultados electorales para cada año.

Vamos a hacerlo con una función para que acumule en orden de votos los gráficos según la fecha porque hemos encontrado muchos problemas para que reordenara correctamente haciéndolo de manera agregada.

```{r}
colores = c("PP"="#1A4CA0",
              "UP"="#542C85",
              "PSOE"="#D50000",
              "PNV"="#018B3F",
              "Cs"="#EB6109",
              "ERC"="#FFCD00",
              "CIU"="#1E3A5F",
              "MP"="#0fddc4",
              "VOX"="#1D7A2A",
              "BNG"="#68abde",
              "EH-BILDU"="#4C9A2A",
              "OTROS"="grey",
              "NA"="black")

# Ordenamos los datos por año y votos descendentes
resumen_agg <- 
  resumen_agg |> 
  arrange(fecha, desc(total_votos_resumen))

# Calcular el porcentaje de votos para cada partido en cada año
resumen_agg_pct <- 
  resumen_agg |> 
  group_by(fecha) |> 
  mutate(
    total_votos_fecha = sum(total_votos_resumen),  # Calcular el total de votos por año
    porcentaje_votos = (total_votos_resumen / total_votos_fecha) * 100  # Calcular el porcentaje
  ) |>
  ungroup()

# Reordenamos los partidos dentro de cada año según el porcentaje de votos
resumen_agg_pct <- 
  resumen_agg_pct |> 
  group_by(fecha) |> 
  arrange(desc(porcentaje_votos)) |>  
  mutate(siglas = factor(siglas, levels = siglas)) |>  
  ungroup()
```

------------------------------------------------------------------------

##  {background-image="fondo_diapos.png" background-size="cover"}

```{r}
# Función para generar gráficos individuales por fecha
generar_graficos <- function(datos, colores) {
  # Crear una lista vacía para almacenar los gráficos
  lista_graficos <- list()
  
  # Obtener las fechas únicas
  fechas_unicas <- unique(datos$fecha)
  
  # Iterar sobre cada fecha
  for (fecha_actual in fechas_unicas) {
    # Filtrar los datos para la fecha actual
    datos_filtrados <- datos |> 
      filter(fecha == fecha_actual) |> 
      arrange(porcentaje_votos) |> 
      mutate(siglas = factor(siglas, levels = siglas))  # Reordenar factores solo para esta fecha
    # Convertir la fecha al formato año/mes (mes en letras abreviadas)
    fecha_formateada <- format(as.Date(fecha_actual), "%b %Y")
    # Crear el gráfico para la fecha actual
    grafico <- ggplot(datos_filtrados, aes(x = "", y = porcentaje_votos, fill = siglas)) +
      geom_col(position = "stack", width = 2.5) +  # Barra apilada única
      geom_text( # Etiquetas con porcentaje solo si es mayor que 2 para que se vea bien
        aes(label = ifelse(porcentaje_votos >= 2, paste0(round(porcentaje_votos, 0), "%"), "")),
        position = position_stack(vjust = 0.5),  # Centrar el texto dentro de las barras
        color = "white",  # Texto en color blanco
        size = 2.75,
        fontface = "bold"
      ) +
      coord_flip() +
      scale_fill_manual(values = colores, name = "Partido") +  # Usar colores personalizados
      labs(
        x = NULL,
        y = NULL,
        title = fecha_formateada
      ) +
      theme_minimal(base_size = 14) +
      theme(
        axis.text.x = element_blank(),  # Eliminar elementos no deseados
        axis.ticks.x = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 9, face = "italic"),
        legend.position = "none"  # Deshabilitar las leyendas individuales
      )
    
    # Agregar el gráfico a la lista
    lista_graficos[[as.character(fecha_actual)]] <- grafico
  }
  
  # Crear el orden de partidos para la leyenda global
orden_leyenda <- 
  c("PSOE", "PP", "UP","Cs","VOX", "ERC", "PNV",  "CIU", "BNG", "EH-BILDU", "MP", "OTROS")

leyenda <- 
  ggplot(resumen_agg_pct, 
         aes(x = siglas, y = 1, fill = siglas)) +
  geom_bar(stat = "identity", width = 0) +  # Asignar valores ficticios a `y`
  scale_fill_manual(values = colores, breaks=orden_leyenda,name = "") +
  theme_void() +
  theme(
    legend.position = "bottom",         # Colocar la leyenda en la parte inferior
    legend.text = element_text(size = 8, family = "Rockwell"),  # Ajustar el tamaño del texto en la leyenda
    legend.key.width = unit(0.5, "cm"),    # Ajustar el ancho de las claves de la leyenda
    legend.direction = "horizontal",       # Disponer la leyenda horizontalmente
    legend.box.spacing = unit(0.5, "cm"),  # Espaciado entre los elementos de la leyenda
    legend.justification = "center"        # Centrar la leyenda
  ) +
  guides(fill = guide_legend(nrow = 1))    # Forzar una sola fila para la leyenda
  
  # Combinar los gráficos en una única columna
  grafico_combinado <- 
    wrap_plots(lista_graficos, ncol = 1) +
    plot_annotation(
      title = "Porcentaje de votos por partido en cada elección",
      theme = theme(plot.title = element_text(hjust = 0.5, size = 16,family = "Rockwell")))
    
  
  # Añadir la leyenda al diseño final con patchwork
  final_plot <- 
    grafico_combinado + leyenda
  
  return(final_plot)
}

# Llamar a la función con los datos y colores
grafico_final <- 
  generar_graficos(resumen_agg_pct, colores)

```

------------------------------------------------------------------------

##  {background-image="fondo_diapos.png" background-size="cover"}

```{r}
# Mostrar el gráfico combinado
grafico_final
```

------------------------------------------------------------------------

## Pregunta_1 {background-image="fondo_diapos.png" background-size="cover"}

¿Qué partido fue el ganador en los municipios con más de 100.000 habitantes (censo) en cada una de las elecciones?

```{r}
# quitar los guiones que separan el cod_mun para poder unirlo después en base a id_municipio 

cod_mun <- cod_mun |> 
  mutate(cod_mun = str_replace_all(cod_mun, "-", ""))

ganadores <- 
  resumen |> 
  filter(censo > 100000) |> 
  group_by(fecha, id_municipio) |> 
  arrange(desc(votos)) |> 
  slice(1) |>  
  summarise(partido_ganador = siglas,
            max_votos = votos,
            censo_municipio = censo) |> 
  ungroup() |> 
  left_join(cod_mun, by = c("id_municipio" = "cod_mun"))

```

------------------------------------------------------------------------

##  {background-image="fondo_diapos.png" background-size="cover"}

-   Añadimos gráfico de España con municipios de más de 100k habitantes coloreados por los partidos que ganaron las elecciones en cada uno de los años electorales

```{r}
#| eval: false

ganadores_LAU <- ganadores |> 
  mutate(id_municipio = substr(id_municipio, 3, 7))


mapa_mas100k_ganadores <- mapSpain::esp_get_munic() |> 
  left_join(ganadores_LAU, by = c("LAU_CODE" = "id_municipio"))

ggplot(mapa_mas100k_ganadores) +
  geom_sf(aes(fill = partido_ganador), alpha = 0.7, color = "grey") +
  scale_fill_manual(
    values = colores) +
  theme_minimal() +
  labs(
    fill = "partido_ganador",
    title = "Partidos ganadores en municipios de más de cien mil habitantes"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "bottom"
  ) +
  facet_wrap(~ fecha)

```

------------------------------------------------------------------------

## Pregunta_2 {background-image="fondo_diapos.png" background-size="cover"}

¿Qué partido fue el segundo cuando el primero fue el PSOE? ¿Y cuando el primero fue el PP?

```{r}
segundos <- 
  resumen |> 
  group_by(fecha, siglas) |> 
  summarise(total_votos = sum(votos), .groups = "drop") |>  
  group_by(fecha) |> 
  slice_max(total_votos, n = 5) |> 
  arrange(fecha, desc(total_votos)) |>
  ungroup()

segundos
```

```{r}
# manera 1

primeros_segundos <- 
  segundos |> 
  group_by(fecha) |> 
  mutate(rank = row_number()) |>  # Clasificar partidos por votos en cada año
  filter(rank <= 2) |>  # Filtrar los dos partidos principales de cada año
  summarise(
    primero = siglas[rank == 1], # partido en primer lugar
    votos_1 = total_votos[rank == 1], # Número de votos del primer lugar
    segundo = siglas[rank == 2],  # partido en segundo lugar
    votos_2 = total_votos[rank == 2]  # Número de votos del segundo lugar
  ) |> 
  ungroup()
primeros_segundos

# Filtrar cuando el primer lugar es PSOE
segundo_cuando_psoe <- 
  primeros_segundos |> 
  filter(primero == "PSOE")
segundo_cuando_psoe

# Filtrar cuando el primer lugar es PP
segundo_cuando_pp <- 
  primeros_segundos |> 
  filter(primero == "PP")
segundo_cuando_pp

```

------------------------------------------------------------------------

##  {background-image="fondo_diapos.png" background-size="cover"}

```{r}
# manera 2

# Reordenar los niveles de 'siglas' en base a 'total_votos' (de mayor a menor)

segundos <- segundos |> 
  group_by(fecha) |> 
  mutate(siglas = fct_reorder(siglas, total_votos, .desc = TRUE)) |> 
  ungroup()

print(levels(segundos$siglas))

ggplot(segundos, 
       aes(x = siglas, 
           y = total_votos, 
           fill = siglas)) +
  geom_col(alpha = 0.8, 
           width = 0.7) +
  scale_fill_manual(values = colores)  +
  labs(title = "Los cinco partidos principales en votos por año",
       subtitle = "Elecciones después de 2008",
       x = "Año y partido",
       y = "Número de votos",
       fill = "Partido") +
  theme_minimal(base_family = "Rockwell") +
  theme(axis.text.x = element_text(angle = 90),
        axis.title.x = element_blank(),
        legend.position = "bottom") +
  facet_wrap(~fecha, nrow = 1, scales = "free_x")
# PP fue el segundo cuando el primero fue el PSOE
# PSOE o UP fueron el segundo cuando el primero fue el PP
```

------------------------------------------------------------------------

## Pregunta_3 {background-image="fondo_diapos.png" background-size="cover"}

-   ¿A quién beneficia la baja participación?

```{r}

# Calcular la participación por municipio
participacion <- 
  resumen |> 
    group_by(id_municipio, siglas) |> 
    summarise(total_votos = sum(votos, na.rm = TRUE), .groups = "drop") |> 
    left_join(resumen |> 
      group_by(id_municipio) |> 
      summarise(participacion_total = sum(votos, na.rm = TRUE), .groups = "drop"),
    by = "id_municipio") |> 
    mutate(participacion_relativa = total_votos / participacion_total)


# Calcular la correlación entre participación total y votos relativos
correlacion <- participacion |> 
  group_by(siglas) |> 
  summarise(correlacion = cor(participacion_total, participacion_relativa, use = "complete.obs"))
#Complete.obs se ocupa de los valores NA, no se si hace falta pero por si acaso lo dejo puesto
#Deberían salir nº entre -1 y 1, si está por encima de 0 la correlación es positiva lo que significa que saldría beneficiado si la participación es alta, y al revés con los resultados negativos


#Un coeficiente de correlación POSITIVO significa que, a medida que AUMENTA la participación, la proporción de votos de ese partido tiende a AUMENTAR

#Correlación positiva → Beneficio con alta participación.
#Correlación negativa → Beneficio con baja participación.



#Estamos haciendo la correlación entre estas dos cosas
#Participación total: el total de votos emitidos en un municipio
#Proporción de votos de un partido (participacion relativa): los votos de un partido como fracción de los votos totales.


# Visualización de resultados con un gráfico de barras
ggplot(correlacion, aes(x = reorder(siglas, correlacion), y = correlacion)) +
  geom_col(fill = "green") +
  labs(
    title = "Correlación entre participación y votos por partido",
    x = "Partido",
    y = "Correlación"
  )  #poner una leyenda con la explicación de cor positiva y negativa y lo que significan con relacion a los datos y el enunciado

```

```{r}
#Otra manera comparando la participación de los distintos años 

#Calculamos la participación total por año, a nivel nacional 
participacion_anual <- resumen |>
  group_by(fecha) |>
  summarise(participacion_total = sum(votos, na.rm = TRUE))

media_votos_años <- mean(participacion_anual$participacion_total)

#Clasificamos los años según si la participación ha sido más alta de lo normal, media o más baja
participacion_anual <- participacion_anual |>
  mutate(categoria_participacion = case_when(
    participacion_total < media_votos_años ~ "Baja_participacion",
    participacion_total >= media_votos_años ~ "Alta_participacion" ))

#Calculamos los votos históricos por partido 
totales_partido <- resumen |>
  group_by(siglas) |>
  summarise(votos_totales = sum(votos, na.rm = TRUE))  
  

#Participación relativa por partido y año
participacion_partido <- resumen |>
  group_by(fecha, siglas) |>
  summarise(votos_partido = sum(votos, na.rm = TRUE), .groups = "drop") |>
  left_join(participacion_anual, by = "fecha") |>
  left_join(totales_partido, by = "siglas") |>
  mutate(participacion_relativa = votos_partido / participacion_total)
#en esta tabla tenemos votos_partido que son los votos de ese partido en esa elección
  #participación_total es el total de votos de la elección de ese año, todos los votantes
  #votos_totales son el total de votos que ha conseguido cada partido en todas las elecciones, suma todos los votos que ha tenido a lo largo de los años 
  #participación_relativa es el total de votos del partido ese año entre el total de votos habidos en esas elecciones

#Analizamos el beneficio por tipo de participación
comparacion <- participacion_partido |>
  filter(categoria_participacion %in% c("Baja_participacion", "Alta_participacion")) |>
  group_by(siglas, categoria_participacion) |>
  summarise(promedio_participacion = mean(participacion_relativa, na.rm = TRUE), .groups = "drop") |>
  pivot_wider(names_from = categoria_participacion, values_from = promedio_participacion) |>
  mutate(beneficio_baja = Baja_participacion - Alta_participacion) |> 
  arrange(desc(beneficio_baja))
# Con el beneficio_baja sacamos la diferencia de porcentaje de votos de cada partido que han tenido los años de elecciones con naja participación entre los años de alta participación
# Los partidos donde beneficio_baja es positivo, significa que salen ganando cuando hay baja participación
#Los partidos con beneficio_baja negativo, significa que pierden votos cuando la participación es alta en las elecciones
```


## Pregunta_4 {background-image="fondo_diapos.png" background-size="cover"}

-   ¿Cómo analizar la relación entre censo y voto? ¿Es cierto que determinados partidos ganan en las zonas rurales?

```{r}
# ANALIZANDO RELACIÓN ENTRE CENSO Y VOTO

# Calculamos el total de votos por municipio y por fecha electoral
relacion_censo_votos <-
  resumen |> 
  group_by(fecha, id_municipio, censo) |> 
  summarise(Total_votos = sum(votos), .groups = "drop")

# Calcular la correlación entre censo y votos totales
correlacion <-
  cor(relacion_censo_votos$censo, relacion_censo_votos$Total_votos)
print(paste("Correlación entre censo y votos totales:",
            round(correlacion, 2)))

# Visualizar la correlación
ggplot(relacion_censo_votos, aes(x = censo, y = Total_votos)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", color = "blue", se = FALSE) +
  labs(
    title = "Relación entre censo y votos totales",
    x = "Censo (personas censadas)",
    y = "Votos totales"
  ) +
  theme_minimal()

```

```{r}
# ANALIZANDO SI CIERTOS PARTIDOS GANAN MÁS EN ZONAS RURALES QUE EN ZONAS URBANAS
# Creamos una tabla en donde guardamos el tipo de zona según el censo:  Rural o Urbano
rurales_urbanas <-
  resumen |> 
  mutate("Zona" = ifelse(censo < 10000, 
                         "Rural", 
                         "Urbano"))

# Calculamos los votos de cada partido para cada tipo de zona en cada elección
votos_por_zona <-
  rurales_urbanas |> 
  group_by(fecha, Zona, siglas) |> 
  summarise(Total_votos = sum(votos), 
            .groups = "drop")

# Creamos el gráfico que muestre las diferencias entre partidos, tipos de zona y fechas de elecciones
ggplot(votos_por_zona, 
       aes(x = siglas, y = Total_votos, fill = Zona)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~ fecha, ncol = 2) + # Dividir gráficos por fecha de elección
  labs(
    title = "Comparación de votos por partido entre zonas rurales y urbanas",
    x = "Siglas",
    y = "Total de Votos",
    fill = "Zona") +
  theme_minimal(base_family = "Rockwell") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Como era de esperar, nos salen 6 gráficos (uno por cada fecha electoral) pero el problema es que puede ser bastante complicado de entender a la hora de exponerlo. Es por ello que creo conveniente poner 3 gráficos pero por separados que muestren cómo ha ido evolucionando los votos a lo largo del tiempo, por ejemplo el gráfico del 2008, el del 2016 y el del 2019
# GRÁFICOS 2008, 2016 Y 2019

# 2008
votos_por_zona_2008 <-
  rurales_urbanas |> 
  filter(fecha == "2008-03-01") |> 
  group_by(Zona, siglas) |> 
  summarise(Total_votos = sum(votos), .groups = "drop")
zona_2008 <-
  ggplot(votos_por_zona_2008, aes(x = siglas, y = Total_votos, fill = Zona)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Comparación de votos por partido entre zonas rurales y urbanas en Marzo de 2008",
    x = "Siglas",
    y = "Total de Votos",
    fill = "Zona"
  ) +
  theme_minimal(base_family = "Rockwell") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  theme(plot.title = element_text(size = 11))

# 2016
votos_por_zona_2016 <-
  rurales_urbanas |> 
  filter(fecha == "2016-06-01") |> 
  group_by(Zona, siglas) |> 
  summarise(Total_votos = sum(votos), .groups = "drop")
zona_2016 <- 
  ggplot(votos_por_zona_2016, aes(x = siglas, y = Total_votos, fill = Zona)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Comparación de votos por partido entre zonas rurales y urbanas en Junio de 2016",
    x = "Siglas",
    y = "Total de Votos",
    fill = "Zona"
  ) +
  theme_minimal(base_family = "Rockwell") +
  theme(axis.text.x = element_text(angle = 45, 
                                   hjust = 1)) + 
  theme(plot.title = element_text(size = 11))

# 2019 (la última)
votos_por_zona_2019 <-
  rurales_urbanas |> 
  filter(fecha == "2019-11-01") |> 
  group_by(Zona, siglas) |> 
  summarise(Total_votos = sum(votos), .groups = "drop")

zona_2019 <-
  ggplot(votos_por_zona_2019, aes(x = siglas, 
                                  y = Total_votos, 
                                  fill = Zona)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Comparación de votos por partido entre zonas rurales y urbanas en Noviembre de 2019",
    x = "Siglas",
    y = "Total de Votos",
    fill = "Zona"
  ) +
  theme_minimal(base_family = "Rockwell") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  theme(plot.title = element_text(size = 11))


ggplotly(zona_2008)
ggplotly(zona_2016)
ggplotly(zona_2019)
```

------------------------------------------------------------------------

## Pregunta_5 {background-image="fondo_diapos.png" background-size="cover"}

-   ¿Cómo calibrar el error de las encuestas (recordemos que las encuestas son de intención de voto a nivel nacional)?

```{r}
#dar el mismo formato de resumen a surveys

surveys_2 <- surveys |> 
  pivot_longer(cols = "UCD":"EV", names_to = "partidos", values_to = "porcentaje", values_drop_na = TRUE )

# agrupar los partidos 

surveys_2 <- 
  surveys_2 |> 
  mutate(partidos = case_when(
    str_detect(partidos, "UP|IU|PODEMOS|COMPROMIS") ~ "UP",
    str_detect(partidos, "PP") ~ "PP",
    str_detect(partidos, "PNV") ~ "PNV",
    str_detect(partidos, "PSOE") ~ "PSOE",
    str_detect(partidos, "MP") ~ "MP",
    str_detect(partidos, "VOX") ~ "VOX",
    str_detect(partidos, "EH-BILDU|AMAIUR") ~ "EH-BILDU",
    str_detect(partidos, "ERC") ~ "ERC",
    str_detect(partidos, "BNG") ~ "BNG",
    str_detect(partidos, "CS") ~ "Cs",
    str_detect(partidos, "CIU|CDC") ~ "CIU", 
    TRUE ~ "OTROS"
  ))

#el valor porcentaje_estimado que aparece en cada pollster para cada eleccion y partido es la media ya que alexandra y yo hemos pensado que para compararlo con los resultados reales lo más conveniente es tener un único dato por casa, partido y elección, ya que es como aparece en los resultados reales 

casas_encuestadoras <- surveys_2 |> 
  select(c(date_elec,id_pollster,pollster,partidos,porcentaje)) |> #seleccionamos solo las columnas necesarias
  mutate(date_elec = format(as.Date(date_elec), "%Y-%m")) |> #quitamos el día para después no tener problemas en la comparación
  group_by(date_elec, id_pollster, partidos) |> 
  mutate(porcentaje_estimado = mean(porcentaje, na.rm = TRUE)) |>
  distinct(date_elec, id_pollster, partidos, .keep_all = TRUE) |> #eliminar filas repetidas
  select(-porcentaje) # ya no nos sirve

# suma de los votos a nivel nacional por eleccion y partido, se convierte este dato en porcentaje para poder compararlo con los datos de surveys

resultados <- resumen |> 
  mutate(fecha = format(as.Date(fecha), "%Y-%m")) |> 
  group_by(fecha, siglas) |>                      
  summarise(Votos_Totales = sum(votos), .groups = "drop") |> 
  group_by(fecha) |> 
  mutate(Porcentaje_real = Votos_Totales / sum(Votos_Totales) * 100) |> 
  select(fecha, siglas, Porcentaje_real)

comparacion <- casas_encuestadoras |> 
  left_join(resultados, by = c("date_elec" = "fecha", "partidos" = "siglas")) |> #unir por fecha y partido 
  mutate(error = Porcentaje_real - porcentaje_estimado) |> 
  select(date_elec, id_pollster, pollster, partidos, Porcentaje_real, porcentaje_estimado, error)

library(plotly)

casas_encuestadoras <- casas_encuestadoras |> 
  rename(fecha = date_elec)

grafico_combinado <- ggplot() +
  geom_bar(data = resultados, 
           aes(x = siglas, y = Porcentaje_real, fill = siglas), 
           stat = "identity", position = "dodge") +   # gráfico de barras con el porcentaje real de votos por partido y elección 
  geom_jitter(data = casas_encuestadoras, 
              aes(x = partidos, y = porcentaje_estimado, label = pollster), 
              color = "black", shape = 16, size = 0.5, 
              position = position_jitter(width = 0.1, height = 0)) + # grafico de puntos con porceentajes estimados de cada casa por partido y elección
  labs(title = "Porcentaje de votos reales y estimaciones por partido",
    x = "Partido",
    y = "Porcentaje") +
  scale_fill_manual(values = colores) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none") +
  facet_wrap(~fecha)


grafico_interactivo <- ggplotly(grafico_combinado)

grafico_interactivo


```

------------------------------------------------------------------------

## Pregunta_6 {background-image="fondo_diapos.png" background-size="cover"}

¿Qué casas encuestadoras acertaron más y cuáles se desviaron más de los resultados?

Sugerencia: Añadir un gráfico interactivo como este donde los puntos son las previsiones de las casas encuestadoreas y las barras los resultados reales

![](images/clipboard-3921849863.png)

```{r}

```

------------------------------------------------------------------------

## Pregunta_7 {background-image="fondo_diapos.png" background-size="cover"}

-  Sabemos que en 2019 se realizaron 2 elecciones pero ¿hubo diferencias en el total de gente que asistió a votar?. ¿Que partidos ganaron votos en la segunda ronda y cuales salieron perdiendo?


```{r}

# Filtrar solo las elecciones que ocurrieron en 2019
eleccion_2019 <-resumen |> 
  filter(year(fecha) == 2019)

# Calculamos la participación total por elección, observamos que en la realizada en abril hay cerca de 2 millones más de votantes que en la de finales del mismo año
participacion_2019 <- eleccion_2019 |> 
  group_by(fecha) |> 
  summarise(participacion_total = sum(votos, na.rm = TRUE)) |> 
  arrange(fecha)

print(participacion_2019)


# Comparamos los votos de cada partido en las dos elecciones de 2019
votos_2019 <- eleccion_2019 |> 
  group_by(fecha, siglas) |> 
  summarise(votos_totales = sum(votos, na.rm = TRUE), .groups = "drop") |> 
  pivot_wider(names_from = fecha, values_from = votos_totales) |> 
  mutate(diferencia_votos = 2019-11-01 - 2019-04-01) |> 
  arrange(desc(diferencia_votos))

#Esto nos devuelve una tabla con los votos de cada grupo de siglas, una columna con la primera elección y otra con la segunda. al final tenemos una tercera columna con la diferencia de votos entre elecciones, los positivos son los partidos que ganaron votos y los negativos los que perdieron electores
print(votos_2019)
```

```{r}
#Ahora unos gráficos para obsrvar visualmente las diferencias entre sufragios
max_part <- max(participacion_2019$participacion_total, na.rm = TRUE)

ggplot(participacion_2019, aes(x = as.factor(fecha), y = participacion_total, fill = fecha)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  labs(title = "Participación total en las elecciones de 2019",
       x = "Fecha de Elección",
       y = "Total de Votantes") +
  theme_minimal()+
  scale_y_continuous(breaks = seq(0, max_part, by = 2e6), labels = scales::label_number(scale = 1e-6, suffix = "M"))
  #scale_fill_manual(values = c("#1f77b4", "#ff7f0e"))  # Colores azul y naranja
```

```{r}
# Gráfico de diferencias de votos por partido
max_dif <- max(abs(votos_2019$diferencia_votos), na.rm = TRUE)

ggplot(votos_2019, aes(x = reorder(siglas, diferencia_votos), y = diferencia_votos, fill = diferencia_votos > 0)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  labs(title = "Diferencia de votos por partido entre abril y noviembre de 2019",
       x = "Partido",
       y = "Diferencia de Votos") +
  theme_minimal() +
  scale_fill_manual(values = c("red", "green")) +  # Rojo para pérdidas, verde para ganancias
  scale_y_continuous(
    breaks = seq(-max_dif, max_dif, by = 500000),  # Intervalos de 2M
    labels = scales::label_number(scale = 1e-6, suffix = "M")  # Convertir a millones
  ) +
  coord_flip()  # Para que el gráfico sea horizontal
```

```{r}
#Gráfico superpuesto con los votos en columnas de cada partido
votos_2019_long <- votos_2019 |> 
  pivot_longer(cols = -c(siglas, diferencia_votos),  # Mantener siglas y diferencia_votos, convertir las fechas
               names_to = "fecha",
               values_to = "votos_totales") |> 
  group_by(siglas) |> 
  summarise(total_votos = sum(votos_totales, na.rm = TRUE)) |> 
  right_join(votos_2019_long, by = "siglas") |> 
  mutate(siglas = fct_reorder(siglas, total_votos, .desc = TRUE)) 


ggplot(votos_2019_long, aes(x = siglas, y = votos_totales, fill = as.factor(fecha))) +
  geom_col(position = "identity", alpha = 0.6) +  # Superponer barras con transparencia
  labs(title = "Comparación de votos por partido en las elecciones de 2019",
       x = "Partido",
       y = "Total de Votos",
       fill = "Fecha de elección") +
  theme_minimal() +
  scale_fill_manual(values = c("#1f77b4", "#ff7f0e")) +  # Azul para abril, naranja para noviembre
  scale_y_continuous(
    labels = scales::label_number(scale = 1e-6, suffix = "M")  # Convertir a millones
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
#Este gráfico funcionaba pero al subirlo no me deja hacer run de la caja de código

```


------------------------------------------------------------------------

## Pregunta_8 {background-image="fondo_diapos.png" background-size="cover"}

Elaborar mapas de España con ganadores y participacion por provincia y ccaa

```{r}
totales_election_data <- 
  election_data |> 
  # Extraer los primeros cuatro dígitos y crear una nueva columna de codigo de provincia
  mutate(provincia = substr(id_municipio, 1, 4)) |> 
  group_by(provincia, fecha) |> 
  summarise(
    total_votos = sum(votos, na.rm = TRUE),
    # Sumar el total de votos
    censo = mean(censo, na.rm = TRUE),
    # Calcular el promedio del censo
    participacion = total_votos / censo,
    # Calcular la participación
    .groups = "drop"
    # Eliminar los grupos
  )
```

```{r}
ganadores_todos <- 
  resumen |> 
  # Extraer los primeros cuatro dígitos y crear una nueva columna de codigo de provincia
  mutate(provincia = substr(id_municipio, 1, 4)) |> 
  group_by(fecha, provincia) |>
  summarise(
    partido_ganador = siglas[which.max(votos)],
    # Encontrar el partido con más votos
    max_votos = max(votos),
    # Encontrar el número máximo de votos
    total_votos = sum(votos), 
     # Calcular el total de votos
    .groups = "drop"      
  )

```

```{r}
# Combinar datos de totales y ganadores
ganadores_por_anno <- 
  totales_election_data |> 
  inner_join(ganadores_todos, by = c("provincia", "fecha")) |> 
  # Dividir la columna cpro en codauto (primeros 2 dígitos) y cpro (últimos 2 dígitos)
  mutate(codauto = substr(provincia, 1, 2),
         cpro = substr(provincia, 3, 4))
```

```{r}

# Obtener el mapa de provincias
data_provincias <- 
  esp_get_prov()
  
# Unir los datos de ganadores y participación al mapa
mapa_datos <- 
  data_provincias |> 
  left_join(ganadores_por_anno, by = "cpro")



ggplot(mapa_datos) +
  geom_sf(aes(fill = partido_ganador,
              alpha = participacion), 
          color = "white", 
          size = 0.2) +
  scale_fill_manual(values = colores, name = "Partido Ganador")+
  facet_wrap(~fecha)+
  labs(
    title = "Ganadores y Participación por Provincia en España",
    subtitle = "Alpha representa la participación"
  ) +
  guides(alpha = "none") +
  theme_minimal(base_family = "Rockwell") 
  

```

------------------------------------------------------------------------

## Pregunta_9 {background-image="fondo_diapos.png" background-size="cover"}

Se suele decir que la población de Zaragoza es una muestra representativa de la población española ¿Son los resultados electorales en Zaragoza extrapolables a la población española, excluyendo los votos regionalistas o independentistas?

```{r}

```

------------------------------------------------------------------------

## Pregunta_10 {background-image="fondo_diapos.png" background-size="cover"}

Serían los resultados obtenidos similares a los reales si nos quedáramos solo con los votos de la sesión1 (por la mañana) o los de la sesión 2 (por la tarde)?

```{r}

```

------------------------------------------------------------------------

##  {background-image="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExdHRwOHhpOTk0OTN4cTBkZzl2eWtmdjRzbnMzdHZmM3BjejdmeHc2ZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/KAdawkDvVuacWBfgbc/giphy.gif" background-size="contain"}

::: r-fit-text
FIN
:::
