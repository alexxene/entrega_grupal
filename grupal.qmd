---
title: "Entrega grupal"
author: "Iratxe Valero Ochoa (DNI:02724987Q), 
        Ángela García Muñoz (DNI:01840008P),
        Javier Ruiz (DNI:25449733A), 
        Javier Muñoz Zacarés (DNI:55136745H),
        Xin Yue Huang (NIE:Y8908945R),
        Alexandra Mihaela Ene (NIE: Y3510242L),
        María Belén Lavanda Rocano (DNI:02723226A) "
format:
  revealjs:
    theme: [style.scss]
    embed-resources: true
execute: 
  echo: true
---

## Paquetes necesarios

```{r}
rm(list = ls())
library(tidyverse)
library(dplyr)
library(glue)
library(forcats)
library(lubridate)
library(extrafont)
library(ggplot2)
library(patchwork)
library(plotly)
library(mapSpain)
```

------------------------------------------------------------------------

## Datos

-   `election_data`: archivo con las elecciones al congreso
-   `cod_mun`: archivo con los códigos y nombres de cada municipio
-   `abbrev`: siglas de cada partido
-   `surveys`: encuestas electorales desde 1982.

```{r}
# NO TOQUES NADA
election_data <- read_csv(file = "./data/datos_elecciones_brutos.csv")
cod_mun <- read_csv(file = "./data/cod_mun.csv")
surveys <- read_csv(file = "./data/historical_surveys.csv")
abbrev <- read_csv(file = "./data/siglas.csv")
```

------------------------------------------------------------------------

## Limpieza de datos

Nos ocupamos primero de las encuestas:

Eliminar columnas de surveys sin info + encuestas a pie de urna y anteriores a 2008. Será necesario hacer un pivot_table como en elecciones

```{r}
surveys <- 
  surveys|> 
  select(-type_survey) |>
  filter(exit_poll == FALSE) |> 
  filter((field_date_to-field_date_from) > 1) |> 
  filter(size>=500 & !is.na(size)) |> 
  filter(date_elec>'2008-1-1')
```

------------------------------------------------------------------------

Seguimos con los datos electorales

```{r}

election_data <-
  election_data |>
  select(-c(tipo_eleccion,
            codigo_distrito_electoral,
            numero_mesas,
            vuelta))

election_data <- election_data|> 
  mutate(id_municipio = glue("{codigo_ccaa}{codigo_provincia}{codigo_municipio}")) |> 
  relocate(id_municipio, .before=codigo_ccaa)

#Mantenemos part1 y part2 pq nos pueden resultar útiles para alguna pregunta más adelante
election_data <- 
  election_data |> 
  select(-c(codigo_ccaa,
            codigo_provincia,
            codigo_municipio,))

election_data <- election_data|> 
  mutate(fecha = glue("1-{mes}-{anno}")) |> 
  relocate(fecha, .before=anno) 

#usamos lubridate
election_data<-election_data |> mutate(fecha=dmy(fecha)) |> select(-c(anno,mes))

# election_data |> distinct(fecha)
```

```{r}
election_data <- 
  election_data |> 
  pivot_longer(cols = "BERDEAK-LOS VERDES":"COALICIÓN POR MELILLA", names_to = "partidos", values_to = "votos", values_drop_na = TRUE )
```

------------------------------------------------------------------------

Utilizamos la variable partidos para agrupar todos ellos en solo 12: "PP" "UP" "PSOE" "PNV" "Cs" "ERC" "CIU" "MP" "VOX" "BNG" "EH-BILDU" "OTROS"

```{r}
# manera 1

resumen <- 
  election_data |> 
  mutate('siglas' = case_when(
  str_detect(partidos, regex("EZKER BA|ENTESA|PODEM|COMPROMÍS|IZQUIERDA UNIDA|ESQUERRA UNI|ESQUERDA UNI|I\\.U\\.|IU ")) ~ "UP",
  str_detect(partidos, "PP|PARTIDO POPULAR|PARTIT POPULAR") ~ "PP",
  str_detect(partidos, "PNV|PARTIDO NACIONALISTA VASCO") ~ "PNV",
  str_detect(partidos, "PSOE|PSC|PARTIDO SOCIALISTA|PARTIT SOCIALISTA|PARTIT DELS SOCIALISTES |PARTIDO DOS SOCIALISTA") ~ "PSOE",
  str_detect(partidos, "MAS PAÍS") ~ "MP",
  str_detect(partidos, "VOX") ~ "VOX",
  str_detect(partidos, "AMAIUR|ARALAR|EUSKO|EUSKAL HERRI|BILDU") ~ "EH-BILDU",
  str_detect(partidos, "ERC|ESQUERRA REPUBLICANA DE C|ESQUERRA REPUBLICANA$|ESQUERRA REPUBLICANA/") ~ "ERC",
  str_detect(partidos, "BNG|BLOQUE") ~ "BNG",
  str_detect(partidos, "CIUTADANS|PARTIDO DE LA CIU") ~ "Cs",
  str_detect(partidos, "CONVERGENCIA I| CONVERGENCIA i|CONVERGÈNCIA|UNIÓ D") ~ "CIU", 
  TRUE ~ "OTROS"
))

resumen
unique(resumen$siglas)
```

```{r}

# manera 2

#Primero tenemos que filtrar el dataset abbrev ya que hay partidos que aceptan múltiples siglas 
abbrev_sinrepes <- 
  abbrev |> 
  group_by(denominacion) |> 
  slice(1)


# Ahora juntamos el dataset election_data con abbrev_sinrepes para darle a cada partido su correspondiente abreviatura
resumen_2 <- 
    election_data |> 
    left_join(abbrev_sinrepes,
              by = c('partidos' = 'denominacion'))
  
resumen_2 <- 
  resumen_2 |> 
   mutate(siglas = case_when(
     str_detect(siglas, regex("ARALAR|^EA$|AMAIUR|EH Bildu", ignore_case = TRUE)) ~ 'EH-BILDU',
     str_detect(siglas, regex("EB-B|ENTESA|PODEMOS|EZKERRA|UP-UPeC|I\\.U\\.", ignore_case = TRUE)) ~ 'UP',
     str_detect(siglas, regex("^PP$|P\\.P-E\\.U\\.|PP-PAR|PP-FORO|PP-UPM", ignore_case = TRUE)) ~ 'PP',
     str_detect(siglas, regex("PNV", ignore_case = TRUE)) ~ 'PNV',
     str_detect(siglas, regex("PSOE|PSC|PSPC|PSE", ignore_case = TRUE)) ~ 'PSOE',
     str_detect(siglas, regex("PAÍS|MÉS COMPROM", ignore_case = TRUE)) ~ 'MP',
     str_detect(siglas, regex("VOX", ignore_case = TRUE)) ~ 'VOX',
     str_detect(siglas, regex("C's", ignore_case = TRUE)) ~ 'Cs',
     str_detect(siglas, regex("CiU|CDC|unio.cat", ignore_case = TRUE)) ~ 'CIU',
     str_detect(siglas, regex("ERC", ignore_case = TRUE)) ~ 'ERC',
     str_detect(siglas, regex("BNG|NÓS", ignore_case = TRUE)) ~ 'BNG',
    # Partidos que no aparecen en abbrev que tenemos que incluir'
     str_detect(partidos, regex("PARTIT POPULAR|PARTIDO POPULAR|\\(PP\\)", ignore_case = TRUE)) ~ 'PP',
     str_detect(partidos, regex("CIUTADANS|PARTIDO DE LA CIU", ignore_case = TRUE)) ~ 'Cs',
     str_detect(partidos, regex("CONVERGÈNCIA I", ignore_case = TRUE)) ~ 'CIU',
     str_detect(partidos, regex("IZQUIERDA UNIDA|EZKER ANITZA|ESQUERRA UNIDA|^IU$|PODEMOS|AHAL DUGU|ESQUERDA UNIDA-OS VERDES", ignore_case = TRUE)) ~ 'UP',
     str_detect(partidos, regex("PSOE|SOCIALISTA OBRER ESPANYOL|DOS SOCIALISTAS", ignore_case = TRUE)) ~ 'PSOE',
     str_detect(partidos, regex("(EH Bildu)|PARTIDO POLITICO ARALAR|EUSKO", ignore_case = TRUE)) ~ 'EH-BILDU',
     str_detect(partidos, regex("ESQUERRA REPUBLICANA/CATALUNYA SÍ|ESQUERRA REPUBLICANA$", ignore_case = TRUE)) ~ 'ERC',   
     TRUE ~ 'OTROS'))

unique(resumen_2$siglas)
```

------------------------------------------------------------------------

Comprobamos si los resultados obtenidos de las 2 maneras son similares:

```{r}

resumen_agg <- resumen |> 
  group_by(siglas,fecha) |> 
  summarise(total_votos_resumen = sum(votos, na.rm = TRUE),.groups = "drop")

resumen_2_agg <- resumen_2 |> 
  group_by(siglas,fecha) |> 
  summarise(total_votos_resumen_2 = sum(votos, na.rm = TRUE),.groups = "drop")

#filtramos por aquellos donde hay diferencias
resumen_total<-resumen_agg |> 
  inner_join(resumen_2_agg,by=c("siglas","fecha")) |> 
  mutate(dif=total_votos_resumen-total_votos_resumen_2) |> 
  filter(dif!=0) |> 
  arrange(desc(dif))

resumen_total
```
-------------------------------------------------------------------

Hemos descubierto que las diferencias principales están en en CIU y UP en 2015. Resumen le da 630.000 votos a CIU, pero resumen2 solo 65.000, según la web del ministerio del interior obtuvieron 567.000 (ver fichero Elecciones.xls en el repositorio de Github).

En cuanto a los votos en 2015 para UP, si se suman los de Podemos, Coalición "En Comú Podem” (En Comú), Coalición “Unidad Popular” y Coalición “Compromís - Podemos - És el Moment”, el ministerio de interior dice que obtuvieron 5.700.000 votos, muy cercano al cálculo de resumen, mientras que resumen2 se queda 500.00 votos corto.

Y parecido ocurre con la agrupación para 2016 para UP: resumen 4.700.000 vs resumen2 4.200.000 vs ministerio 5.000.000.

Por tanto creemos que la agrupación resumen es más precisa y usaremos esa agrupación para el resto del trabajo.

------------------------------------------------------------------------

### Pregunta 0. Mostrar un gráfico con los resultados electorales para cada año.

Vamos a hacerlo con una función para que acumule en orden de votos los gráficos según la fecha porque hemos encontrado muchos problemas para que reordenara correctamente haciéndolo de manera agregada.

```{r}
colores = c("PP"="#1A4CA0",
              "UP"="#542C85",
              "PSOE"="#D50000",
              "PNV"="#018B3F",
              "Cs"="#EB6109",
              "ERC"="#FFCD00",
              "CIU"="#1E3A5F",
              "MP"="#0fddc4",
              "VOX"="#1D7A2A",
              "BNG"="#68abde",
              "EH-BILDU"="#4C9A2A",
              "OTROS"="pink",
              "NA"="gray")



# Ordenamos los datos por año y votos descendentes
resumen_agg <- resumen_agg |> 
  arrange(fecha, desc(total_votos_resumen))

# Calcular el porcentaje de votos para cada partido en cada año
resumen_agg_pct <- resumen_agg |> 
  group_by(fecha) |> 
  mutate(
    total_votos_fecha = sum(total_votos_resumen),  # Calcular el total de votos por año
    porcentaje_votos = (total_votos_resumen / total_votos_fecha) * 100  # Calcular el porcentaje
  ) |>
  ungroup()

# Reordenamos los partidos dentro de cada año según el porcentaje de votos
resumen_agg_pct <- resumen_agg_pct |> 
  group_by(fecha) |> 
  arrange(desc(porcentaje_votos)) |>  
  mutate(siglas = factor(siglas, levels = siglas)) |>  
  ungroup()

(resumen_agg_pct)

```

------------------------------------------------------------------------

```{r}

# Función para generar gráficos individuales por fecha
generar_graficos <- function(datos, colores) {
  # Crear una lista vacía para almacenar los gráficos
  lista_graficos <- list()
  
  # Obtener las fechas únicas
  fechas_unicas <- unique(datos$fecha)
  
  # Iterar sobre cada fecha
  for (fecha_actual in fechas_unicas) {
    # Filtrar los datos para la fecha actual
    datos_filtrados <- datos |> 
      filter(fecha == fecha_actual) |> 
      arrange(porcentaje_votos) |> 
      mutate(siglas = factor(siglas, levels = siglas))  # Reordenar factores solo para esta fecha
    # Convertir la fecha al formato año/mes (mes en letras abreviadas)
    fecha_formateada <- format(as.Date(fecha_actual), "%b %Y")
    # Crear el gráfico para la fecha actual
    grafico <- ggplot(datos_filtrados, aes(x = "", y = porcentaje_votos, fill = siglas)) +
      geom_col(position = "stack", width = 1.8) +  # Barra apilada única
      geom_text( # Etiquetas con porcentaje solo si es mayor que 2 para que se vea bien
        aes(label = ifelse(porcentaje_votos >= 2, paste0(round(porcentaje_votos, 0), "%"), "")),
        position = position_stack(vjust = 0.5),  # Centrar el texto dentro de las barras
        color = "white",  # Texto en color blanco
        size = 2.75,
        fontface = "bold"
      ) +
      coord_flip() +
      scale_fill_manual(values = colores, name = "Partido") +  # Usar colores personalizados
      labs(
        x = NULL,
        y = NULL,
        title = fecha_formateada
      ) +
      theme_minimal(base_size = 14) +
      theme(
        axis.text.x = element_blank(),  # Eliminar elementos no deseados
        axis.ticks.x = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        plot.title = element_text(size = 9, face = "italic"),
        legend.position = "none"  # Deshabilitar las leyendas individuales
      )
    
    # Agregar el gráfico a la lista
    lista_graficos[[as.character(fecha_actual)]] <- grafico
  }
  
  # Crear el orden de partidos para la leyenda global
orden_leyenda <- c("PSOE", "PP", "UP","Cs","VOX", "ERC", "PNV",  "CIU", "BNG", "EH-BILDU", "MP", "OTROS")
leyenda <- ggplot(resumen_agg_pct, aes(x = siglas, y = 1, fill = siglas)) +
  geom_bar(stat = "identity", width = 0) +  # Asignar valores ficticios a `y`
  scale_fill_manual(values = colores, breaks=orden_leyenda,name = "") +
  theme_void() +
  theme(
    legend.position = "bottom",         # Colocar la leyenda en la parte inferior
    legend.text = element_text(size = 8),  # Ajustar el tamaño del texto en la leyenda
    legend.key.width = unit(0.5, "cm"),    # Ajustar el ancho de las claves de la leyenda
    legend.direction = "horizontal",       # Disponer la leyenda horizontalmente
    legend.box.spacing = unit(0.5, "cm"),  # Espaciado entre los elementos de la leyenda
    legend.justification = "center"        # Centrar la leyenda
  ) +
  guides(fill = guide_legend(nrow = 1))    # Forzar una sola fila para la leyenda
  
  # Combinar los gráficos en una única columna
  grafico_combinado <- wrap_plots(lista_graficos, ncol = 1) +
    plot_annotation(
      title = "Porcentaje de votos por partido en cada elección",
      theme = theme(plot.title = element_text(hjust = 0.5, size = 16))
    )
  
  # Añadir la leyenda al diseño final con patchwork
  final_plot <- grafico_combinado + leyenda
  
  return(final_plot)
}

# Llamar a la función con los datos y colores
grafico_final <- generar_graficos(resumen_agg_pct, colores)

# Mostrar el gráfico combinado
print(grafico_final)



```

------------------------------------------------------------------------

### Pregunta_1

¿Qué partido fue el ganador en los municipios con más de 100.000 habitantes (censo) en cada una de las elecciones?

```{r}
# quitar los guiones que separan el cod_mun para poder unirlo después en base a id_municipio 

cod_mun <- cod_mun |> 
  mutate(cod_mun = str_replace_all(cod_mun, "-", ""))

ganadores <- 
  resumen |> 
  filter(censo > 100000) |> 
  group_by(fecha, id_municipio) |> 
  arrange(desc(votos)) |> 
  slice(1) |>  
  summarise(partido_ganador = siglas,
            max_votos = votos,
            censo_municipio = censo) |> 
  ungroup() |> 
  left_join(cod_mun, by = c("id_municipio" = "cod_mun"))

```

------------------------------------------------------------------------

####Añadimos gráfico de España con municipios de más de 100k habitantes coloreados por los partidos que ganaron las elecciones en cada uno de los años electorales

```{r}
#| eval: false

ganadores_LAU <- ganadores |> 
  mutate(id_municipio = substr(id_municipio, 3, 7))


mapa_mas100k_ganadores <- mapSpain::esp_get_munic() |> 
  left_join(ganadores_LAU, by = c("LAU_CODE" = "id_municipio"))

ggplot(mapa_mas100k_ganadores) +
  geom_sf(aes(fill = partido_ganador), alpha = 0.7, color = "grey") +
  scale_fill_manual(
    values = colores) +
  theme_minimal() +
  labs(
    fill = "partido_ganador",
    title = "Partidos ganadores en municipios de más de cien mil habitantes"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "bottom"
  ) +
  facet_wrap(~ fecha)

```


### Pregunta_2

¿Qué partido fue el segundo cuando el primero fue el PSOE? ¿Y cuando el primero fue el PP?

```{r}
segundos <- 
  resumen |> 
  group_by(fecha, siglas) |> 
  summarise(total_votos = sum(votos), .groups = "drop") |>  
  group_by(fecha) |> 
  slice_max(total_votos, n = 5) |> 
  arrange(fecha, desc(total_votos)) |>
  ungroup()

segundos
```

```{r}
# manera 1

primeros_segundos <- 
  segundos |> 
  group_by(fecha) |> 
  mutate(rank = row_number()) |>  # Clasificar partidos por votos en cada año
  filter(rank <= 2) |>  # Filtrar los dos partidos principales de cada año
  summarise(
    primero = siglas[rank == 1], # partido en primer lugar
    votos_1 = total_votos[rank == 1], # Número de votos del primer lugar
    segundo = siglas[rank == 2],  # partido en segundo lugar
    votos_2 = total_votos[rank == 2]  # Número de votos del segundo lugar
  ) |> 
  ungroup()
primeros_segundos

# Filtrar cuando el primer lugar es PSOE
segundo_cuando_psoe <- 
  primeros_segundos |> 
  filter(primero == "PSOE")
segundo_cuando_psoe

# Filtrar cuando el primer lugar es PP
segundo_cuando_pp <- 
  primeros_segundos |> 
  filter(primero == "PP")
segundo_cuando_pp

```

-------------------------------------------------------------------

```{r}
# manera 2

# Reordenar los niveles de 'siglas' en base a 'total_votos' (de mayor a menor)

segundos <- segundos |> 
  group_by(fecha) |> 
  mutate(siglas = fct_reorder(siglas, total_votos, .desc = TRUE)) |> 
  ungroup()

print(levels(segundos$siglas))

ggplot(segundos, 
       aes(x = siglas, 
           y = total_votos, 
           fill = siglas)) +
  geom_col(alpha = 0.8, 
           width = 0.7) +
  scale_fill_manual(values = colores)  +
  labs(title = "Los cinco partidos principales en votos por año",
       subtitle = "Elecciones después de 2008",
       x = "Año y partido",
       y = "Número de votos",
       fill = "Partido") +
  theme_minimal(base_family = "Rockwell") +
  theme(axis.text.x = element_text(angle = 90),
        axis.title.x = element_blank(),
        legend.position = "bottom") +
  facet_wrap(~fecha, nrow = 1, scales = "free_x")
# PP fue el segundo cuando el primero fue el PSOE
# PSOE o UP fueron el segundo cuando el primero fue el PP
```

-------------------------------------------------------------------

### Pregunta_3

¿A quién beneficia la baja participación?

```{r}

# Calcular la participación por municipio
participacion <- 
  resumen |> 
    group_by(id_municipio, siglas) |> 
    summarise(total_votos = sum(votos, na.rm = TRUE), .groups = "drop") |> 
    left_join(resumen |> 
      group_by(id_municipio) |> 
      summarise(participacion_total = sum(votos, na.rm = TRUE), .groups = "drop"),
    by = "id_municipio") |> 
    mutate(participacion_relativa = total_votos / participacion_total)


# Calcular la correlación entre participación total y votos relativos
correlacion <- participacion |> 
  group_by(siglas) |> 
  summarise(correlacion = cor(participacion_total, participacion_relativa, use = "complete.obs"))
#Complete.obs se ocupa de los valores NA, no se si hace falta pero por si acaso lo dejo puesto
#Deberían salir nº entre -1 y 1, si está por encima de 0 la correlación es positiva lo que significa que saldría beneficiado si la participación es alta, y al revés con los resultados negativos


#Un coeficiente de correlación POSITIVO significa que, a medida que AUMENTA la participación, la proporción de votos de ese partido tiende a AUMENTAR

#Correlación positiva → Beneficio con alta participación.
#Correlación negativa → Beneficio con baja participación.



#Estamos haciendo la correlación entre estas dos cosas
#Participación total: el total de votos emitidos en un municipio
#Proporción de votos de un partido (participacion relativa): los votos de un partido como fracción de los votos totales.


# Visualización de resultados con un gráfico de barras
ggplot(correlacion, aes(x = reorder(siglas, correlacion), y = correlacion)) +
  geom_col(fill = "green") +
  labs(
    title = "Correlación entre participación y votos por partido",
    x = "Partido",
    y = "Correlación"
  )  #poner una leyenda con la explicación de cor positiva y negativa y lo que significan con relacion a los datos y el enunciado

```


### Pregunta_4

¿Cómo analizar la relación entre censo y voto? ¿Es cierto que determinados partidos ganan en las zonas rurales?

```{r}
# Para analizar la relación entre censo y voto, al ser 2 variables continuas podemos hacerlo mediante una correlación
resumen |> 
  summarise(correlacion = cor(censo, votos, use = "complete.obs", method = "pearson"))


# Paara ver si hay partidos que se favorecen en las zonas rurales habría que sacar 2 tablas de datos con partidos ganadores:                             Una que tuviera los partidos ganadores en zonas rurales (censo < 10000), y otra que tuviera los partidos ganadores en zonas urbanas (censo > 10000)


# Partidos ganadores en zonas rurales
resumen |> 
  filter(censo < 10000) |> 
  group_by(year(fecha), id_municipio) |> 
  arrange(desc(votos)) |> 
  slice(1) |> 
  summarise(partido_ganador = siglas,
             max_votos = votos,
            censo_municipio = censo) |>
  ungroup() |> 
  count(partido_ganador)
  

# Partidos ganadores en zonas no rurales
resumen |> 
  filter(censo > 10000) |> 
  group_by(year(fecha), id_municipio) |> 
  arrange(desc(votos)) |> 
  slice(1) |> 
  summarise(partido_ganador = siglas,
             max_votos = votos,
            censo_municipio = censo) |>
  ungroup() |> 
  count(partido_ganador)

# Para poder ver de forma más clara si hay partidos que se benefician o no, podríamos hacer un gráfico de barras comparando los partidos ganadores en zonas urbanas y rurales
```

-------------------------------------------------------------------

### Pregunta_5

¿Cómo calibrar el error de las encuestas (recordemos que las encuestas son de intención de voto a nivel nacional)?

```{r}

```

-------------------------------------------------------------------

### Pregunta_6

¿Qué casas encuestadoras acertaron más y cuáles se desviaron más de los resultados?

Sugerencia: Añadir un gráfico interactivo como este donde los puntos son las previsiones de las casas encuestadoreas y las barras los resultados reales

![](images/clipboard-3921849863.png)

```{r}
#dar el mismo formato de resumen a surveys

surveys_2 <- surveys |> 
  pivot_longer(cols = "UCD":"EV", names_to = "partidos", values_to = "porcentaje", values_drop_na = TRUE )

# agrupar los partidos 

surveys_3 <- 
  surveys_2 |> 
  mutate(partidos = case_when(
    str_detect(partidos, "UP|IU|PODEMOS|COMPROMIS") ~ "UP",
    str_detect(partidos, "PP") ~ "PP",
    str_detect(partidos, "PNV") ~ "PNV",
    str_detect(partidos, "PSOE") ~ "PSOE",
    str_detect(partidos, "MP") ~ "MP",
    str_detect(partidos, "VOX") ~ "VOX",
    str_detect(partidos, "EH-BILDU|AMAIUR") ~ "EH-BILDU",
    str_detect(partidos, "ERC") ~ "ERC",
    str_detect(partidos, "BNG") ~ "BNG",
    str_detect(partidos, "CS") ~ "Cs",
    str_detect(partidos, "CIU|CDC") ~ "CIU", 
    TRUE ~ "OTROS"
  ))

#sumar los porcentajes para que no aparezcan datos repetidos

surveys_4 <- surveys_3 |> 
  group_by(date_elec, id_pollster, field_date_from, field_date_to, partidos) |> 
  mutate(porcentaje = sum(porcentaje, na.rm = TRUE)) |> 
  distinct()

# suma de los votos a nivel nacional por eleccion y partido, se convierte este dato en porcentaje para poder compararlo con los datos de surveys

resultados <- resumen |> 
  group_by(fecha, siglas) |>                      
  summarise(Votos_Totales = sum(votos), .groups = "drop") |> 
  group_by(fecha) |> 
  mutate(Porcentaje_real = Votos_Totales / sum(Votos_Totales) * 100) |> 
  select(fecha, siglas, Porcentaje_real)

casas_encuestadoras <- surveys_4 |> 
  select(-c(id_pollster, media, field_date_from, field_date_to, exit_poll, turnout)) |> 
  group_by(date_elec, pollster, partidos) |> 
  summarise(porcentaje_estimado = mean(porcentaje, na.rm = TRUE), .groups = "drop")

#el valor que aparece en cada pollster para cada eleccion y partido es la media ya que alexandra y yo hemos pensado que para compararlo con los resultados reales lo más conveniente es tener un único dato por casa y elección, ya que se ha hecho más de una estimación en varias ocasiones 

comparacion <- resultados |> 
  inner_join(casas_encuestadoras, by = c("siglas" = "partidos")) |> #hay que unirlo por eleccion tambien pero no se como porque el dia no coincide 
  mutate(Diferencia = Porcentaje_real - porcentaje_estimado)

#ahora hemos pensado que tenemos que hacer un inner join o un left join dependiendo de lo que queramos que se quede en las tablas. No nos decidimos por cual y ademas tendriamos que tener lo de las siglas y las fechas todas en un mismo formato para poder unirlas bien. ¿que creeis que hacer?

# # Paso 4: Comparar resultados reales con encuestas
# comparacion <- resultados_nacionales %>%
#   left_join(encuestas_agregadas, by = "Partido") %>%
#   mutate(Diferencia = Encuestas - Real)
# 
# # Mostrar la tabla de comparación
# print(comparacion)
```

-------------------------------------------------------------------

### Pregunta_7

Nos dice algo sobre el resultado final de las elecciones que se hayan emitido más votos en la primera sesión que en la segunda? ¿Podemos afirmar que los votantes de un partido son más madrugadores que otros?

```{r}

```

-------------------------------------------------------------------

### Pregunta_8

Elaborar mapas de España con ganadores y participacion por provincia y ccaa

```{r}
totales_election_data <- election_data |> 
  group_by(id_municipio, fecha) |>  # Agrupa por id_municipio y fecha
  summarise(
    total_votos = sum(votos, na.rm = TRUE),
    censo=mean(censo),
    participacion = total_votos /censo,
    .groups = "drop")
```

-------------------------------------------------------------------

### Pregunta_9

Se suele decir que la población de Zaragoza es una muestra representativa de la población española ¿Son los resultados electorales en Zaragoza extrapolables a la población española, excluyendo los votos regionalistas o independentistas?

```{r}

```



###Pregunta_10
Serían los resultados obtenidos similares a los reales si nos quedáramos solo con los votos de la sesión1 (por la mañana) o los de la sesión 2 (por la tarde)?


```{r}

```
